{"mappings":"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","sources":["src/script.js","src/app.js","src/userLog.json"],"sourcesContent":["import \"./app\";\nconst typingForm = document.querySelector(\".typing-form\");\nconst chatContainer = document.querySelector(\".chat-history\");\nconst incomingChat = document.querySelector(\".chat-list\");\nconst deleteChatButton = document.querySelector(\"#delete-chat-button\");\nconst submitButton = document.querySelector(\"#send-message-button\");\nconst nameField = document.querySelector(\"#nameField\");\nconst costumeField = document.querySelector(\"#costumeField\");\nlet firstName;\nlet costume;\nlet sessionHistory = [];\n// State variables\nlet isResponseGenerating = false;\n\n// API configuration\n\nconst API_URL = \"http://localhost:3000/generate-nickname\";\n\nconst splitTextByAsterisk = function (phrase) {\n\tconst firstAsteriskIndex = phrase.indexOf(\"*\");\n\tconst lastAsteriskIndex = phrase.lastIndexOf(\"*\");\n\t// If no asterisks are found, return the whole phrase in the \"before\" part and an empty \"after\" part\n\tif (firstAsteriskIndex === -1 || lastAsteriskIndex === -1) {\n\t\treturn {\n\t\t\tbefore: phrase,\n\t\t\tafter: \"\",\n\t\t};\n\t}\n\t// Get the text before the first asterisk\n\tconst beforeText = phrase.substring(0, firstAsteriskIndex).trim();\n\t// Get the text after the last asterisk\n\tconst afterText = phrase.substring(lastAsteriskIndex + 1).trim();\n\t// Return the two parts as an object\n\treturn {\n\t\tbefore: beforeText,\n\t\tafter: afterText,\n\t};\n};\nconst isolateNickname = function (nickname) {\n\tconst match = nickname.match(/\\*(.*?)\\*/);\n\treturn match ? match[1] : null;\n};\nconst deleteEntry = async entry => {\n\ttry {\n\t\tconst response = await fetch(\"http://localhost:3000/log\", {\n\t\t\tmethod: \"DELETE\",\n\t\t\theaders: {\"Content-Type\": \"application/json\"},\n\t\t\tbody: JSON.stringify({\n\t\t\t\tentryID: entry,\n\t\t\t}),\n\t\t});\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(err);\n\t\t}\n\t\tloadChatHistory();\n\t} catch (err) {\n\t\tconsole.log(err.stack);\n\t}\n};\n\n// Load chat history from server\nconst loadChatHistory = async () => {\n\tconst html = `<div class=\"message-content\">\n\t\t\t\t\t<p class=\"text\"></p>\n                </div>\n\t\t\t\t<span class=\"material-symbols-rounded icon hide\">delete</span>`;\n\ttry {\n\t\tconst response = await fetch(\"http://localhost:3000/log\", {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: {\"Content-Type\": \"application/json\"},\n\t\t});\n\t\tif (!response.ok) throw new Error(\"Failed to fetch log data\");\n\t\tlet data = await response.json();\n\t\tdata = data.sessionHistory;\n\t\tfor (entry in data) {\n\t\t\tsessionHistory.push(data[entry]);\n\t\t\tconst message = data[entry].result;\n\t\t\tconst messageID = data[entry].msgID;\n\t\t\tconst div = createMessageElement(html);\n\t\t\tdiv.setAttribute(\"data-id\", messageID);\n\t\t\tdiv.querySelector(\".text\").append(message);\n\t\t\tchatContainer.prepend(div);\n\t\t}\n\t\tconsole.log(`Refreshed log with ${data.length} entries`);\n\t} catch (error) {\n\t\tconsole.log(error);\n\t}\n};\n// Create a new message element and return it\nconst createMessageElement = (content, ...classes) => {\n\tconst div = document.createElement(\"div\");\n\tdiv.classList.add(\"message\", ...classes);\n\tdiv.innerHTML = content;\n\treturn div;\n};\n\n// Show typing effect by displaying words one by one\nconst showTypingEffect = (text, textElements, incomingMessageDiv) => {\n\tconst splitText = splitTextByAsterisk(text);\n\tconst textParts = [splitText.before.split(\" \"), [isolateNickname(text)], splitText.after.split(\" \")];\n\tfor (let i = 0; i < textElements.length; i++) {\n\t\tconst words = textParts[i]; // Use the correct part for each element\n\t\tconst element = textElements[i];\n\t\tlet currentWordIndex = 0;\n\n\t\tconst typingInterval = setInterval(() => {\n\t\t\t// Append each word to the text element with a space\n\t\t\telement.innerText += (currentWordIndex === 0 ? \"\" : \" \") + words[currentWordIndex++];\n\n\t\t\t// If all words are displayed\n\t\t\tif (currentWordIndex === words.length) {\n\t\t\t\tclearInterval(typingInterval);\n\t\t\t\tisResponseGenerating = false;\n\t\t\t\t// Remove loading icon when done\n\t\t\t\t// incomingMessageDiv.querySelector(\".icon\").classList.remove(\"hide\");\n\t\t\t}\n\n\t\t\tchatContainer.scrollTo(0, chatContainer.scrollHeight); // Scroll to the bottom\n\t\t}, 50);\n\t}\n};\n\n// Fetch response from the API based on user message\nconst generateAPIResponse = async incomingMessageDiv => {\n\tconst textElements = incomingMessageDiv.querySelectorAll(\".text\"); // Getting text element\n\ttry {\n\t\t// Send a POST request to the API with the user's message\n\t\tconst response = await fetch(API_URL, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: {\"Content-Type\": \"application/json\"},\n\t\t\tbody: JSON.stringify({\n\t\t\t\tname: firstName,\n\t\t\t\tcostume: costume,\n\t\t\t}),\n\t\t});\n\t\tconst data = await response.json();\n\t\tif (!response.ok) throw new Error(data.err);\n\t\tconst apiResponse = data.nickname;\n\t\tshowTypingEffect(apiResponse, textElements, incomingMessageDiv); // Show typing effect\n\t\tchatContainer.innerHTML = \" \";\n\t\tloadChatHistory();\n\t} catch (err) {\n\t\t// Handle error\n\t\tconsole.log(`Couldn't fetch nickname: ${err}`);\n\t\tisResponseGenerating = false;\n\t\ttextElements[1].innerText = err;\n\t\ttextElements[1].parentElement.closest(\".message\").classList.add(\"error.message\");\n\t} finally {\n\t\tincomingMessageDiv.classList.remove(\"loading\");\n\t}\n};\n\n// Show a loading animation while waiting for the API response\nconst showLoadingAnimation = () => {\n\tconst html = `<div class=\"message-content\">\n\t<p class=\"text text1\"></p>\n\t<p class=\"text text3 nickname-bold\"></p>\n\t<p class=\"text text2\"></p>\n\t<div class=\"loading-indicator\">\n\t\t<div class=\"loading-bar\"></div>\n\t\t<div class=\"loading-bar\"></div>\n\t\t<div class=\"loading-bar\"></div>\n\t</div>\n</div>\n`;\n\n\tconst incomingMessageDiv = createMessageElement(html, \"incoming\", \"loading\");\n\tincomingChat.appendChild(incomingMessageDiv);\n\t// chatContainer.scrollTo(0, chatContainer.scrollHeight); // Scroll to the bottom\n\tgenerateAPIResponse(incomingMessageDiv);\n};\n\n// Handle sending outgoing chat messages\nconst handleOutgoingChat = () => {\n\tfirstName = nameField.value;\n\tcostume = costumeField.value;\n\n\tif (!firstName || !costume || isResponseGenerating) return; // Exit if there is no message or response is generating\n\n\tisResponseGenerating = true;\n\n\ttypingForm.reset(); // Clear input field\n\tincomingChat.innerHTML = \"\";\n\tsetTimeout(showLoadingAnimation, 500); // Show loading animation after a delay\n};\n\n// Delete all chats from local storage when button is clicked\ndeleteChatButton.addEventListener(\"click\", () => {\n\tif (confirm(\"Are you sure you want to delete all the chats?\")) {\n\t\tdeleteEntry();\n\t}\n});\n\n// chatContainer.addEventListener(\"click\", e => {\n// \tlet elements = chatContainer.querySelectorAll(\".message\");\n// \telements.forEach(item => {\n// \t\titem.addEventListener(\"click\", function (e) {\n// \t\t\tconst dataID = this.getAttribute(\"data-id\");\n// \t\t\tdeleteEntry(dataID);\n// \t\t});\n// \t});\n// });\n\n// Prevent default form submission and handle outgoing chat\ntypingForm.addEventListener(\"submit\", e => {\n\te.preventDefault();\n\thandleOutgoingChat();\n});\n\nloadChatHistory();\n","// server.js\nrequire(\"dotenv\").config();\nconst express = require(\"express\");\nconst cors = require(\"cors\");\nconst {GoogleGenerativeAI} = require(\"@google/generative-ai\");\nconst {v4: uuidv4} = require(\"uuid\");\nconst app = express();\nconst apiKey = process.env.GEMINI_API_KEY;\nconst genAI = new GoogleGenerativeAI(apiKey);\n//Writing to server storage\nvar fs = require(\"fs\");\ndelete require.cache[require.resolve(\"./userLog.json\")];\nlet sessionHistory = require(\"./userLog.json\");\napp.use(cors()); // Enable CORS for all origins\napp.use(express.json()); // Enable JSON parsing for incoming requests\n\n// Endpoint to serve page\napp.get(\"/\", function (req, res) {\n\tres.sendFile(__dirname + \"../index.html\");\n});\n\nconst isolateNickname = function (nickname) {\n\tconst match = nickname.match(/\\*(.*?)\\*/);\n\treturn match ? match[1] : null;\n};\n\nconst model = genAI.getGenerativeModel({\n\tmodel: \"gemini-1.5-flash-8b\",\n\tsystemInstruction: 'Respond with a creative, spooky, halloween-themed nickname that utilizes their first name and is topical based on the costume they are wearing. Make sure you respond in a fun, lighthearted way The responses should emphasize creativity and fun while being respectful and appropriate for all audiences. Avoid any references to violence, gore, death, or inappropriate language. The nicknames should remain lighthearted friendly. Avoid repetetiveness, and be poetic. Introduce the nickname with a brief phrase welcoming them to Zombie brook, for instance: /\"Welcome to Zombiebrook, [nickname]!/\". Here is some data for inspiration: https://namesbudy.com/alias-names/halloween-nicknames/ and https://creativenomenclature.com/nicknames/spooky-nicknames/ Make the nickname revealed at the last part of the response, not in the middle. I don\\'t want any language after the nickname. When you return the result, you must wrap the nickname itself in an asterix so I can isolate it. If the user inputs a response that is rude, uses offense language, is inappropriate or sexually explicity, do not generate a nickname and provide a one sentence explanation as to why why you chose not to accept their input. ',\n});\n\nconst generationConfig = {\n\ttemperature: 1.2,\n\ttopP: 0.9,\n\ttopK: 41,\n\tmaxOutputTokens: 200,\n\tresponseMimeType: \"text/plain\",\n};\n\nconst writeToLog = sessionHistory => {\n\tfs.writeFile(\"userLog.json\", JSON.stringify(sessionHistory, null, 2), \"utf8\", err => {\n\t\tif (err) {\n\t\t\tconsole.error(\"Error writing to userLog.json:\", err);\n\t\t\treturn err; // Handle error appropriately (e.g., logging it or notifying the user)\n\t\t}\n\t});\n};\n\napp.delete(\"/log\", async function (req, res) {\n\t// const entry = req.body.entryID;\n\t// let matchedEntry = sessionHistory.find(obj => obj.msgID == entry || {});\n\t// console.log(matchedEntry);\n\tsessionHistory = [];\n\ttry {\n\t\tawait writeToLog(sessionHistory);\n\t\tres.status(200).json({message: `Chat history deleted`});\n\t} catch (err) {\n\t\tconsole.log(err);\n\t\tres.status(500).json({err});\n\t}\n});\n\n// GET endpoint to get log history\napp.get(\"/log\", async (req, res) => {\n\ttry {\n\t\tres.status(200).json({sessionHistory});\n\t} catch (err) {\n\t\tres.status(500).json({error: \"Could not fetch log\"});\n\t}\n});\n// POST endpoint to generate nickname\napp.post(\"/generate-nickname\", async (req, res) => {\n\t// Destructure `name` and `costume` from the request body (assuming client sends in contents)\n\tconst {name, costume} = req.body;\n\tconst promptString = `My name is ${name} and I am dressed as ${costume}.`;\n\ttry {\n\t\t// Create a unique session ID\n\t\tlet currentSessionId = uuidv4();\n\t\tconst result = await model.generateContent(promptString, {\n\t\t\tgenerationConfig,\n\t\t\thistory: sessionHistory[currentSessionId],\n\t\t});\n\t\tconst nickname = await result.response.text();\n\t\tconst cleanResult = await isolateNickname(nickname);\n\t\tconst time = new Date();\n\t\t// Append this interaction to the session history (if needed later for more context)\n\t\tsessionHistory.push({\n\t\t\ttime: `${time}`,\n\t\t\tmsgID: `${currentSessionId}`,\n\t\t\trole: \"user\",\n\t\t\tname: `${name}`,\n\t\t\tcostume: `${costume}`,\n\t\t\trole: \"model\",\n\t\t\tresult: `${cleanResult}`,\n\t\t});\n\n\t\tres.status(200).json({nickname});\n\t\twriteToLog(sessionHistory);\n\t} catch (err) {\n\t\tconsole.log(err);\n\t\tres.status(500).json({err});\n\t}\n});\n\nmodule.exports = app;\n","[\n  {\n    \"time\": \"Mon Oct 14 2024 12:35:41 GMT-0400 (Eastern Daylight Time)\",\n    \"msgID\": \"363a79bb-6ba9-49fb-b7fd-5766f03e9557\",\n    \"role\": \"model\",\n    \"name\": \"Violet\",\n    \"costume\": \"tinkerbelle\",\n    \"result\": \"Violet's Whisper\"\n  },\n  {\n    \"time\": \"Mon Oct 14 2024 12:38:07 GMT-0400 (Eastern Daylight Time)\",\n    \"msgID\": \"c9d602bd-5d49-4802-8dbd-78f739fbda1d\",\n    \"role\": \"model\",\n    \"name\": \"Justin\",\n    \"costume\": \"Bored dad\",\n    \"result\": \"Papa-Zoom!\"\n  }\n]"],"names":[],"version":3,"file":"script.js.map","sourceRoot":"../"}