{"mappings":"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","sources":["<anon>","src/js/script.js"],"sourcesContent":["const typingForm = document.querySelector(\".typing-form\");\nconst chatContainer = document.querySelector(\".chat-history\");\nconst incomingChat = document.querySelector(\".chat-list\");\nconst deleteChatButton = document.querySelector(\"#delete-chat-button\");\nconst submitButton = document.querySelector(\"#send-message-button\");\nconst nameField = document.querySelector(\"#nameField\");\nconst costumeField = document.querySelector(\"#costumeField\");\nlet firstName;\nlet costume;\nlet sessionHistory = [];\n// State variables\nlet isResponseGenerating = false;\n// API configuration\nconst API_URL = \"http://localhost:3000/generate-nickname\";\nconst splitTextByAsterisk = function(phrase) {\n    const firstAsteriskIndex = phrase.indexOf(\"*\");\n    const lastAsteriskIndex = phrase.lastIndexOf(\"*\");\n    // If no asterisks are found, return the whole phrase in the \"before\" part and an empty \"after\" part\n    if (firstAsteriskIndex === -1 || lastAsteriskIndex === -1) return {\n        before: phrase,\n        after: \"\"\n    };\n    // Get the text before the first asterisk\n    const beforeText = phrase.substring(0, firstAsteriskIndex).trim();\n    // Get the text after the last asterisk\n    const afterText = phrase.substring(lastAsteriskIndex + 1).trim();\n    // Return the two parts as an object\n    return {\n        before: beforeText,\n        after: afterText\n    };\n};\nconst isolateNickname = function(nickname) {\n    const match = nickname.match(/\\*(.*?)\\*/);\n    return match ? match[1] : null;\n};\nconst deleteEntry = async (entry1)=>{\n    try {\n        const response = await fetch(\"http://localhost:3000/log\", {\n            method: \"DELETE\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                entryID: entry1\n            })\n        });\n        if (!response.ok) throw new Error(err);\n        loadChatHistory();\n    } catch (err1) {\n        console.log(err1.stack);\n    }\n};\n// Load chat history from server\nconst loadChatHistory = async ()=>{\n    const html = `<div class=\"message-content\">\n\t\t\t\t\t<p class=\"text\"></p>\n                </div>\n\t\t\t\t<span class=\"material-symbols-rounded icon hide\">delete</span>`;\n    try {\n        const response = await fetch(\"http://localhost:3000/log\", {\n            method: \"GET\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        if (!response.ok) throw new Error(\"Failed to fetch log data\");\n        let data = await response.json();\n        data = data.sessionHistory;\n        for(entry in data){\n            sessionHistory.push(data[entry]);\n            const message = data[entry].result;\n            const messageID = data[entry].msgID;\n            const div = createMessageElement(html);\n            div.setAttribute(\"data-id\", messageID);\n            div.querySelector(\".text\").append(message);\n            chatContainer.prepend(div);\n        }\n        console.log(`Refreshed log with ${data.length} entries`);\n    } catch (error) {\n        console.log(error);\n    }\n};\n// Create a new message element and return it\nconst createMessageElement = (content, ...classes)=>{\n    const div = document.createElement(\"div\");\n    div.classList.add(\"message\", ...classes);\n    div.innerHTML = content;\n    return div;\n};\n// Show typing effect by displaying words one by one\nconst showTypingEffect = (text, textElements, incomingMessageDiv)=>{\n    const splitText = splitTextByAsterisk(text);\n    const textParts = [\n        splitText.before.split(\" \"),\n        [\n            isolateNickname(text)\n        ],\n        splitText.after.split(\" \")\n    ];\n    for(let i = 0; i < textElements.length; i++){\n        const words = textParts[i]; // Use the correct part for each element\n        const element = textElements[i];\n        let currentWordIndex = 0;\n        const typingInterval = setInterval(()=>{\n            // Append each word to the text element with a space\n            element.innerText += (currentWordIndex === 0 ? \"\" : \" \") + words[currentWordIndex++];\n            // If all words are displayed\n            if (currentWordIndex === words.length) {\n                clearInterval(typingInterval);\n                isResponseGenerating = false;\n            // Remove loading icon when done\n            // incomingMessageDiv.querySelector(\".icon\").classList.remove(\"hide\");\n            }\n            chatContainer.scrollTo(0, chatContainer.scrollHeight); // Scroll to the bottom\n        }, 50);\n    }\n};\n// Fetch response from the API based on user message\nconst generateAPIResponse = async (incomingMessageDiv)=>{\n    const textElements = incomingMessageDiv.querySelectorAll(\".text\"); // Getting text element\n    try {\n        // Send a POST request to the API with the user's message\n        const response = await fetch(API_URL, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                name: firstName,\n                costume: costume\n            })\n        });\n        const data = await response.json();\n        if (!response.ok) throw new Error(data.err);\n        const apiResponse = data.nickname;\n        showTypingEffect(apiResponse, textElements, incomingMessageDiv); // Show typing effect\n        chatContainer.innerHTML = \" \";\n        loadChatHistory();\n    } catch (err1) {\n        // Handle error\n        console.log(`Couldn't fetch nickname: ${err1}`);\n        isResponseGenerating = false;\n        textElements[1].innerText = err1;\n        textElements[1].parentElement.closest(\".message\").classList.add(\"error.message\");\n    } finally{\n        incomingMessageDiv.classList.remove(\"loading\");\n    }\n};\n// Show a loading animation while waiting for the API response\nconst showLoadingAnimation = ()=>{\n    const html = `<div class=\"message-content\">\n\t<p class=\"text text1\"></p>\n\t<p class=\"text text3 nickname-bold\"></p>\n\t<p class=\"text text2\"></p>\n\t<div class=\"loading-indicator\">\n\t\t<div class=\"loading-bar\"></div>\n\t\t<div class=\"loading-bar\"></div>\n\t\t<div class=\"loading-bar\"></div>\n\t</div>\n</div>\n`;\n    const incomingMessageDiv = createMessageElement(html, \"incoming\", \"loading\");\n    incomingChat.appendChild(incomingMessageDiv);\n    // chatContainer.scrollTo(0, chatContainer.scrollHeight); // Scroll to the bottom\n    generateAPIResponse(incomingMessageDiv);\n};\n// Handle sending outgoing chat messages\nconst handleOutgoingChat = ()=>{\n    firstName = nameField.value;\n    costume = costumeField.value;\n    if (!firstName || !costume || isResponseGenerating) return; // Exit if there is no message or response is generating\n    isResponseGenerating = true;\n    typingForm.reset(); // Clear input field\n    incomingChat.innerHTML = \"\";\n    setTimeout(showLoadingAnimation, 500); // Show loading animation after a delay\n};\n// Delete all chats from local storage when button is clicked\ndeleteChatButton.addEventListener(\"click\", ()=>{\n    if (confirm(\"Are you sure you want to delete all the chats?\")) deleteEntry();\n});\n// chatContainer.addEventListener(\"click\", e => {\n// \tlet elements = chatContainer.querySelectorAll(\".message\");\n// \telements.forEach(item => {\n// \t\titem.addEventListener(\"click\", function (e) {\n// \t\t\tconst dataID = this.getAttribute(\"data-id\");\n// \t\t\tdeleteEntry(dataID);\n// \t\t});\n// \t});\n// });\n// Prevent default form submission and handle outgoing chat\ntypingForm.addEventListener(\"submit\", (e)=>{\n    e.preventDefault();\n    handleOutgoingChat();\n});\nloadChatHistory();\n\n//# sourceMappingURL=index.88e8ad90.js.map\n","const typingForm = document.querySelector(\".typing-form\");\nconst chatContainer = document.querySelector(\".chat-history\");\nconst incomingChat = document.querySelector(\".chat-list\");\nconst deleteChatButton = document.querySelector(\"#delete-chat-button\");\nconst submitButton = document.querySelector(\"#send-message-button\");\nconst nameField = document.querySelector(\"#nameField\");\nconst costumeField = document.querySelector(\"#costumeField\");\nlet firstName;\nlet costume;\nlet sessionHistory = [];\n// State variables\nlet isResponseGenerating = false;\n\n// API configuration\n\nconst API_URL = \"http://localhost:3000/generate-nickname\";\n\nconst splitTextByAsterisk = function (phrase) {\n\tconst firstAsteriskIndex = phrase.indexOf(\"*\");\n\tconst lastAsteriskIndex = phrase.lastIndexOf(\"*\");\n\t// If no asterisks are found, return the whole phrase in the \"before\" part and an empty \"after\" part\n\tif (firstAsteriskIndex === -1 || lastAsteriskIndex === -1) {\n\t\treturn {\n\t\t\tbefore: phrase,\n\t\t\tafter: \"\",\n\t\t};\n\t}\n\t// Get the text before the first asterisk\n\tconst beforeText = phrase.substring(0, firstAsteriskIndex).trim();\n\t// Get the text after the last asterisk\n\tconst afterText = phrase.substring(lastAsteriskIndex + 1).trim();\n\t// Return the two parts as an object\n\treturn {\n\t\tbefore: beforeText,\n\t\tafter: afterText,\n\t};\n};\nconst isolateNickname = function (nickname) {\n\tconst match = nickname.match(/\\*(.*?)\\*/);\n\treturn match ? match[1] : null;\n};\nconst deleteEntry = async entry => {\n\ttry {\n\t\tconst response = await fetch(\"http://localhost:3000/log\", {\n\t\t\tmethod: \"DELETE\",\n\t\t\theaders: {\"Content-Type\": \"application/json\"},\n\t\t\tbody: JSON.stringify({\n\t\t\t\tentryID: entry,\n\t\t\t}),\n\t\t});\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(err);\n\t\t}\n\t\tloadChatHistory();\n\t} catch (err) {\n\t\tconsole.log(err.stack);\n\t}\n};\n\n// Load chat history from server\nconst loadChatHistory = async () => {\n\tconst html = `<div class=\"message-content\">\n\t\t\t\t\t<p class=\"text\"></p>\n                </div>\n\t\t\t\t<span class=\"material-symbols-rounded icon hide\">delete</span>`;\n\ttry {\n\t\tconst response = await fetch(\"http://localhost:3000/log\", {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: {\"Content-Type\": \"application/json\"},\n\t\t});\n\t\tif (!response.ok) throw new Error(\"Failed to fetch log data\");\n\t\tlet data = await response.json();\n\t\tdata = data.sessionHistory;\n\t\tfor (entry in data) {\n\t\t\tsessionHistory.push(data[entry]);\n\t\t\tconst message = data[entry].result;\n\t\t\tconst messageID = data[entry].msgID;\n\t\t\tconst div = createMessageElement(html);\n\t\t\tdiv.setAttribute(\"data-id\", messageID);\n\t\t\tdiv.querySelector(\".text\").append(message);\n\t\t\tchatContainer.prepend(div);\n\t\t}\n\t\tconsole.log(`Refreshed log with ${data.length} entries`);\n\t} catch (error) {\n\t\tconsole.log(error);\n\t}\n};\n// Create a new message element and return it\nconst createMessageElement = (content, ...classes) => {\n\tconst div = document.createElement(\"div\");\n\tdiv.classList.add(\"message\", ...classes);\n\tdiv.innerHTML = content;\n\treturn div;\n};\n\n// Show typing effect by displaying words one by one\nconst showTypingEffect = (text, textElements, incomingMessageDiv) => {\n\tconst splitText = splitTextByAsterisk(text);\n\tconst textParts = [splitText.before.split(\" \"), [isolateNickname(text)], splitText.after.split(\" \")];\n\tfor (let i = 0; i < textElements.length; i++) {\n\t\tconst words = textParts[i]; // Use the correct part for each element\n\t\tconst element = textElements[i];\n\t\tlet currentWordIndex = 0;\n\n\t\tconst typingInterval = setInterval(() => {\n\t\t\t// Append each word to the text element with a space\n\t\t\telement.innerText += (currentWordIndex === 0 ? \"\" : \" \") + words[currentWordIndex++];\n\n\t\t\t// If all words are displayed\n\t\t\tif (currentWordIndex === words.length) {\n\t\t\t\tclearInterval(typingInterval);\n\t\t\t\tisResponseGenerating = false;\n\t\t\t\t// Remove loading icon when done\n\t\t\t\t// incomingMessageDiv.querySelector(\".icon\").classList.remove(\"hide\");\n\t\t\t}\n\n\t\t\tchatContainer.scrollTo(0, chatContainer.scrollHeight); // Scroll to the bottom\n\t\t}, 50);\n\t}\n};\n\n// Fetch response from the API based on user message\nconst generateAPIResponse = async incomingMessageDiv => {\n\tconst textElements = incomingMessageDiv.querySelectorAll(\".text\"); // Getting text element\n\ttry {\n\t\t// Send a POST request to the API with the user's message\n\t\tconst response = await fetch(API_URL, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: {\"Content-Type\": \"application/json\"},\n\t\t\tbody: JSON.stringify({\n\t\t\t\tname: firstName,\n\t\t\t\tcostume: costume,\n\t\t\t}),\n\t\t});\n\t\tconst data = await response.json();\n\t\tif (!response.ok) throw new Error(data.err);\n\t\tconst apiResponse = data.nickname;\n\t\tshowTypingEffect(apiResponse, textElements, incomingMessageDiv); // Show typing effect\n\t\tchatContainer.innerHTML = \" \";\n\t\tloadChatHistory();\n\t} catch (err) {\n\t\t// Handle error\n\t\tconsole.log(`Couldn't fetch nickname: ${err}`);\n\t\tisResponseGenerating = false;\n\t\ttextElements[1].innerText = err;\n\t\ttextElements[1].parentElement.closest(\".message\").classList.add(\"error.message\");\n\t} finally {\n\t\tincomingMessageDiv.classList.remove(\"loading\");\n\t}\n};\n\n// Show a loading animation while waiting for the API response\nconst showLoadingAnimation = () => {\n\tconst html = `<div class=\"message-content\">\n\t<p class=\"text text1\"></p>\n\t<p class=\"text text3 nickname-bold\"></p>\n\t<p class=\"text text2\"></p>\n\t<div class=\"loading-indicator\">\n\t\t<div class=\"loading-bar\"></div>\n\t\t<div class=\"loading-bar\"></div>\n\t\t<div class=\"loading-bar\"></div>\n\t</div>\n</div>\n`;\n\n\tconst incomingMessageDiv = createMessageElement(html, \"incoming\", \"loading\");\n\tincomingChat.appendChild(incomingMessageDiv);\n\t// chatContainer.scrollTo(0, chatContainer.scrollHeight); // Scroll to the bottom\n\tgenerateAPIResponse(incomingMessageDiv);\n};\n\n// Handle sending outgoing chat messages\nconst handleOutgoingChat = () => {\n\tfirstName = nameField.value;\n\tcostume = costumeField.value;\n\n\tif (!firstName || !costume || isResponseGenerating) return; // Exit if there is no message or response is generating\n\n\tisResponseGenerating = true;\n\n\ttypingForm.reset(); // Clear input field\n\tincomingChat.innerHTML = \"\";\n\tsetTimeout(showLoadingAnimation, 500); // Show loading animation after a delay\n};\n\n// Delete all chats from local storage when button is clicked\ndeleteChatButton.addEventListener(\"click\", () => {\n\tif (confirm(\"Are you sure you want to delete all the chats?\")) {\n\t\tdeleteEntry();\n\t}\n});\n\n// chatContainer.addEventListener(\"click\", e => {\n// \tlet elements = chatContainer.querySelectorAll(\".message\");\n// \telements.forEach(item => {\n// \t\titem.addEventListener(\"click\", function (e) {\n// \t\t\tconst dataID = this.getAttribute(\"data-id\");\n// \t\t\tdeleteEntry(dataID);\n// \t\t});\n// \t});\n// });\n\n// Prevent default form submission and handle outgoing chat\ntypingForm.addEventListener(\"submit\", e => {\n\te.preventDefault();\n\thandleOutgoingChat();\n});\n\nloadChatHistory();\n"],"names":["firstName","costume","typingForm","document","querySelector","chatContainer","incomingChat","deleteChatButton","nameField","costumeField","sessionHistory","isResponseGenerating","splitTextByAsterisk","phrase","firstAsteriskIndex","indexOf","lastAsteriskIndex","lastIndexOf","before","after","substring","trim","isolateNickname","nickname","match","deleteEntry","entry1","response","fetch","method","headers","body","JSON","stringify","entryID","ok","Error","err","loadChatHistory","err1","console","log","stack","html","data","json","entry","push","message","result","messageID","msgID","div","createMessageElement","setAttribute","append","prepend","length","error","content","classes","createElement","classList","add","innerHTML","showTypingEffect","text","textElements","incomingMessageDiv","splitText","textParts","split","i","words","element","currentWordIndex","typingInterval","setInterval","innerText","clearInterval","scrollTo","scrollHeight","generateAPIResponse","querySelectorAll","name","apiResponse","parentElement","closest","remove","showLoadingAnimation","appendChild","handleOutgoingChat","value","reset","setTimeout","addEventListener","confirm","e","preventDefault"],"version":3,"file":"index.88e8ad90.js.map","sourceRoot":"../"}